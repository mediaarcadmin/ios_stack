<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="DC.Title" content="Unknown"/>
    <style type="text/css">body { margin: 0%;padding: 0%;} .cover { text-align: center;margin-left: 0%;margin-right: 0%;} .coverpage { text-align: center;vertical-align: middle;text-shadow: #000 0px 1px 1px;margin-left: 0px;margin-right: 0px;margin-top: 0px;padding-top: 3em;margin-botton: 3em;font-size: 3.0em;background: #2F4F4F;} .coverimg { margin-top: 0%;margin-left: 0%;margin-right: 0%;width: 100%;} p { margin-left: 1em;margin-right: 1em;text-align: justify;} span { margin-top: 0%;margin-bottom: 0%;margin-left: 1em;margin-right: 1em;text-align: justify;text-indent: 1.5em;} div { margin-top: 0%;margin-bottom: 0%;margin-left: 1em;margin-right: 1em;text-align: justify;text-indent: 1.5em;} p { margin-top: 0%;margin-bottom: 0%;margin-left: 1em;margin-right: 1em;text-align: justify;text-indent: 1.5em;} blockquote { margin-top: 0%;margin-bottom: 0%;margin-left: 1em;margin-right: 1em;text-align: justify;text-indent: 1.5em;} h1 { text-align: center;} h2 { text-align: center;} h3 { text-align: center;} h4 { text-align: center;} h5 { text-align: center;} h6 { text-align: center;}</style>
  </head>
  <body>
    <div>
      <h1>Unknown</h1>
    </div>
    <div>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 168 — #28
✐
✐
✐
✐
✐
✐
168 Chapter 3 a73 Recursive Thinking
Fair enough. Deﬁnition 1.6 doesstipulate what odd numbersare, once and for
all. We should therefore view the recursive deﬁnition in Example 3.21 as an
equivalent way to describe the set of odd natural numbers. Of course, we need
to prove that these two deﬁnitionsare equivalent; we’ll do thisin the next
section.
Example 2.5 illustrated how to organize data into a binary search tree.
More generally, any graph with thistype of structure iscalled a binary tree.
These graphs have a natural recursive deﬁnition.
Example 3.22 Give a recursive deﬁnition for the set of all binary trees.
Solution: For convenience, let’s allow the “empty tree” consisting of no vertices
and no edges to be a simple case of a binary tree. A single vertex could also
be considered to be a binary tree. Using these two building blocks, a new tree
can be formed from two existing treesby joining the two treesunder a common
root node. So we can write the following deﬁnition for a binary tree. Note that
thisdeﬁnition also deﬁnesthe root of the binary tree.
B
1
. The empty tree isa binary tree.
B
2
. A single vertex is a binary tree. In this case, the vertex is the root of the
tree.
R. If T
1
and T
2
are binary treeswith roots r
1
and r
2
, respectively, then the
tree
T
1
T
2
r
2
r
1
r
isa binary tree with root r. Here the circlesrepresent the binary trees T
1
and T
2
. If either of these trees T
i
(i =1,2) isthe empty tree, then there
isno edge from r to T
i
. ♦
As we saw in Section 3.1, seeing the recursive structure to an object can
be the key to deﬁning a recurrence relation. In Example 3.6, we observed that
a complete binary tree is made of two smaller complete binary trees. The deﬁ-
nition in Example 3.22 generalizesthisobservation.
3.3.3 Recursive Geometry
We can think of a recurrence relationR(n) as a rule for constructing a sequence
of numbers R(1),R(2),R(3),.... For example, the recurrence relation
R(n)=
braceleftBigg
2ifn=1
radicalbig
R(n−1) if n>1</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 169 — #29
✐
✐
✐
✐
✐
✐
3.3 Recursive Deﬁnitions 169
producesthe sequence
2,1.414,1.189,1.091,1.044,1.022,1.011,1.005,...
to three decimal places. We say that the limit of this sequence is 1 because the
numbers in this sequence get closer and closer to 1 as n getslarger.
Similarly, we can consider the limit of a recursive deﬁnition of geometric
patterns. This is one way to construct fractals, a special type of shape with
inﬁnite layers of self-similarity. The following examples illustrate this process.
Example 3.23 Deﬁne a sequence of shapes as follows.
B. K(1) isan equilateral triangle.
R. For n>1, K(n) isformed by replacing each line segment
of K(n−1) with the shape
such that the central vertex points outwards.
Figure 3.7 showsthe ﬁrst three termsof thissequence.
The limit of this sequence of shapes is a fractal known as the Koch snowﬂake,
shown in Figure 3.8.
K(3)K(2)K(1)
Figure 3.7 The curves K(1), K(2), and K(3).</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 170 — #30
✐
✐
✐
✐
✐
✐
170 Chapter 3 a73 Recursive Thinking
Figure 3.8 The Koch snowﬂake fractal.
The next example illustrates how to ﬁnd a recursive structure, given a
fractal.
Example 3.24 The fractal model for the Badda-Bing axiomatic system of
Example 1.17 is shown in Figure 3.9. Notice that the pattern starts with a
Figure 3.9 A fractal model for the Badda-Bing geometry.
central square in the middle, with smaller squares on each vertex of this square,
and smaller squares on all those vertices, and so on. Each time the squares get
smaller, they do so by a factor of 1/2. These observations lead to a deﬁnition
for a sequence of shapes B(1),B(2),B(3),... whose limit is the Badda-Bing
fractal.
B. B(1) isa square.
R. For n>1, B(n) isformed from B(n− 1) by adding squares to every
vertex v that lieson only one square S. Such a new square must have v</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 171 — #31
✐
✐
✐
✐
✐
✐
3.3 Recursive Deﬁnitions 171
asa vertex, be oriented the same way as S, touch S at v only, and have
side length 1/2 the side length of S.
Figure 3.10 showsthe ﬁrst three termsof thissequence.
B(1) B(2) B(3)
Figure3.10 The ﬁrst three terms of a sequence whose limit is the Badda-Bing
fractal.
The above deﬁnition deﬁnes a sequence of shapesB(1),B(2),B(3),...that
approximate the Badda-Bing fractal. None of these shapes is the fractal, ex-
actly. The actual fractal consists of inﬁnitely many squares, while each approx-
imating shape B(n) contains ﬁnitely many. However, it is possible to deﬁne
the fractal as a recursive set, following the idea in Example 3.21. The following
statements deﬁne a set B of pointsin the plane.
B. isin S.
R. If isin S (in any orientation), so are .
Thisdeﬁnition issomewhat informal, but it helpsusthink about the recur-
sive nature of the fractal. If you were to draw the fractal using this deﬁnition,
you would start with the ﬁve squares in the base case, then you would apply
the recursive case to the four squares on the corners, then you would apply
the recursive case to the twelve little squares on the corners, and so on. This
hypothetical “bottom-up” construction continues forever, with the squares be-
coming arbitrarily small and numerous, accounting for the fractal nature of the
set B.
Of course, we haven’t proved that the limit of the sequence B(1),B(2),
B(3),... isthe set B; we aren’t going to study limits in enough detail to make
such claims. The purpose of this example is get us thinking recursively.
The mathematical study of fractals is relatively new; most of the important
discoveriesin thisﬁeld weren’t made until the second half of the 20
th
century,
when computers became widely available to mathematicians. While these ob-
jects can be fascinating in themselves, their self-similar structure can help us
visualize the concept of recursion. In a fractal, you can see copies of the fractal</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 172 — #32
✐
✐
✐
✐
✐
✐
172 Chapter 3 a73 Recursive Thinking
one layer down; each arm of the snowﬂake in Figure 3.8 has smaller, identically
shaped arms coming oﬀ of it. This is the sort of observation you must make
when you write recursive deﬁnitions. How does a string contain a smaller string
on the inside? How can we build up a greater odd number from a lesser one?
Fractals are pretty, but they are important because they show us a picture of
recursive thinking.
3.3.4 Recursive Jokes
One measure of how well you understand a certain concept is whether you
understand humor based on the concept. Here are some recursive jokes. Maybe
these aren’t very funny, but hopefully you don’t need them explained to you.
In order to understand recursion, you must understand recursion.
It isn’t unusual for the following to be in the index of a book:
Recursion, see Recursion.
Some acronyms are recursive jokes: VISA (VISA International Service As-
sociation), GNU (GNU’s Not Unix), and PHP (PHP Hypertext Protocol).
An early spin-oﬀ of the text editor EMACS wasnamed EINE (EINE IsNot
EMACS), and one of its successors was called ZWEI (ZWEI Was EINE Ini-
tially).
Certain well-known camp songs have recursive deﬁnitions, for example,
“99 bottlesof beer on the wall ....” Thissong isa good example of top-down
thinking.
Exercises 3.3
1. Write the recurrence relation for the Fibonacci numbers(Deﬁnition 3.1)
in the form of a recursive deﬁnition, with two base cases and one recursive
case.
2. See Example 3.16. Why is the ﬁrst part of the deﬁnition necessary? (In
other words, why must λ be deﬁned asa palindrome?)
3. Give a recursive deﬁnition for the setX of all binary strings with an even
number of 0’s.
4. See Example 3.17. Give a recursive deﬁnition for the set Y of all binary
strings with more 0’sthan 1’s.
5. Use the deﬁnition of the reverse of a string in Example 3.18 to compute
(cubs)
R
. Justify each step using the deﬁnition.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 173 — #33
✐
✐
✐
✐
✐
✐
3.3 Recursive Deﬁnitions 173
6. Refer to Example 3.15. Suppose that the symbols can be compared, so
for anyiandj withinegationslash=j, eithera
i
&lt;a
j
ora
j
&lt;a
i
. Modify the deﬁnition
so that it deﬁnes the set of all strings whose symbols are in increasing
order.
7. Let K be the set of all cities that you can get to from Toronto by taking
ﬂights (or sequences of ﬂights) on commercial airlines. Give a recursive
deﬁnition of K.
8. Create your own example of an object or situation whose recursive deﬁ-
nition isthe same asthe Kevin Bacon movie club in Example 3.14.
9. Deﬁne a set X of numbersasfollows.
B. 2 ∈X.
R
1
. If x∈X,sois 10x.
R
2
. If x∈X,soisx+4.
(a) List all the elements of X that are less than 30.
(b) Explain why there are no odd numbersin X.
10. Give a recursive deﬁnition for the set of even integers (including both
positive and negative even integers).
11. Give a recursive deﬁnition for the set of all powers of 2.
12. Deﬁne a set X recursively as follows.
B. 3 and 7 are in X.
R. If x and y are in X,soisx+y. (Here it is possible that x=y.)
Decide which of the following numbersare in X. Explain each decision.
(a) 24
(b) 1,000,000
(c) 11
13. Deﬁne a set X recursively as follows.
B. 12 ∈X.
R
1
. If x∈X and x iseven, then x/2 ∈X.
R
2
. If x∈X and x isodd, then x+1∈X.
List all the elements of X.
14. Give a recursive deﬁnition for the set X of all natural numbersthat are
one or two more than a multiple of 10. In other words, give a recursive
deﬁnition for the set {1,2,11,12,21,22,31,32,...}.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 174 — #34
✐
✐
✐
✐
✐
✐
174 Chapter 3 a73 Recursive Thinking
15. In Example 3.22, we gave a recursive deﬁnition of a binary tree. Suppose
we modify thisdeﬁnition by deleting part B
1
, so that an empty tree is
not a binary tree. A tree satisfying this revised deﬁnition is called a full
binary tree.
(a) Give an example of a full binary tree with ﬁve nodes.
(b) Give an example of a binary tree with ﬁve nodesthat isnot a full
binary tree.
16. LetGbe an undirected graph, possibly not connected. The diﬀerent pieces
that make upGare called the connected components ofG. More precisely,
for any vertex v in G, the connected component G
v
containing v isthe
graph whose vertices and edges are those that lie on some path starting
at v. Give a recursive deﬁnition for G
v
. (Hint: Mimic Example 3.14.)
17. Refer to Example 3.23. Suppose that the perimeter of K(1) is3. Give a
recurrence relation for the perimeter P(n)ofthenth shape K(n) in the
sequence. Guess at a closed-form solution to P(n). What doesthissay
about the perimeter of the Koch snowﬂake fractal?
18. The Sierpinski gasket fractal is shown in Figure 3.11. In the ﬁrst part of
Example 3.24, we saw how to deﬁne a sequence of shapes to approximate a
given fractal. Using thisexample asa guide, give a recursive deﬁnition for
S(n), where the limit of the sequenceS(1),S(2),S(3),...isthe Sierpinski
gasket.
Figure 3.11 The Sierpinski gasket.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 175 — #35
✐
✐
✐
✐
✐
✐
3.3 Recursive Deﬁnitions 175
19. In the second part of Example 3.24, we saw an informal way to deﬁne a
fractal as a recursively deﬁned set. Using this example as a guide, give an
informal deﬁnition of the Sierpinski gasket as a recursively deﬁned set.
20. Give a recursive deﬁnition forT(n), where the sequenceT(1),T(2),T(3),...
is the fractal tree shown in Figure 3.12. Figure 3.13 shows the ﬁrst three
termsof thissequence.
21. Given an informal deﬁnition of the fractal tree in Figure 3.12 asa recur-
sively deﬁned set.
Figure 3.12 A fractal tree. The “buds” at the top are actually tiny branches
whose shape is similar to the larger branches lower in the tree. These branches
become smaller and smaller (and more numerous) as you move up the tree.
T(1) T(2) T(3)
Figure 3.13 The ﬁrst three terms of a sequence whose limit is the fractal in
Figure 3.12.
22. Give a recursive deﬁnition forC(n), where the sequenceC(1),C(2),C(3),...
is the fractal shown in Figure 3.14. (Hint: Figure 3.15 shows the ﬁrst and</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 176 — #36
✐
✐
✐
✐
✐
✐
176 Chapter 3 a73 Recursive Thinking
third termsof thissequence. In Figure 3.15, if the largest circle hasradius
4, then the other circleshave radii 2 and 1.)
23. Give an informal deﬁnition of the shape in Figure 3.14 as a recursively
deﬁned set.
Figure 3.14 A fractal composed of circles.
C(1) C(3)
Figure 3.15 The ﬁrst and third terms of a sequence whose limit is the fractal
in Figure 3.14.
3.4 Proof by Induction
In Section 3.2, we used induction to verify a closed-form solution to a recurrence
relation. There are lotsof other statementsin mathematicsthat lend themselves
to proofs by induction. Here are some examples.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 177 — #37
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 177
• The sum of the ﬁrst n natural numbersis
n(n+1)
2
.
• A binary tree of height n haslessthan 2
n+1
nodes.
• A convex n-gon has
n(n−3)
2
diagonals.
What do these examples have in common? They are all statements containing
the variablen, and in each case,nstands for some natural number—each state-
ment takesthe form “Statement(n)” for all n. Furthermore, these statements
all involve objects that have some sort of recursive structure. In this section
we extend the technique of induction to prove factsabout recursively deﬁned
objects.
3.4.1 The Principle of Induction
To prove that a closed form solution f(n) matchesa recurrence relation R(n),
we had to prove the following:
For all n≥ 1, R(n)=f(n).
We did this by ﬁrst checking the base case R(1) =f(1), and then proving that
R(k)=f(k) followsfrom the inductive hypothesis R(k−1) =f(k−1), for any
k>1. The principle of mathematical induction generalizesthisapproach.
The Principle of Mathematical Induction. To prove the statement
“Statement(n), for all n≥ 1,”
it suﬃces to prove
1. Statement(1), and
2. Statement(k−1) ⇒ Statement(k), for k>1.
This principle is plausible by the same reasoning used in Section 3.2: Step
2 establishes a chain of implications:
Statement(1) ⇒ Statement(2) ⇒ Statement(3) ⇒···,
while step 1 gets the chain of implications started. It follows that these two
steps, taken together, establish Statement(n) for all n≥ 1.
We label this a “principle” because, strictly speaking, we can’t prove it
asa theorem. In advanced treatmentsof the foundationsof mathematics, this
statement is usually assumed as an axiom.
2
Recall that part 1 of the princi-
ple iscalled the base case and part 2 iscalled the inductive step. In proving
the inductive step, the assumption that Statement(k− 1) istrue iscalled the
inductive hypothesis.
2. Often an equivalent condition called the well-ordering principle is assumed as an axiom:
every nonempty set of positive integers contains a least element.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 178 — #38
✐
✐
✐
✐
✐
✐
178 Chapter 3 a73 Recursive Thinking
3.4.2 Examples
Mathematical induction isoften the technique to use when you can think about
a problem recursively. The discussion of the next result illustrates how to take
a recursive viewpoint.
Theorem 3.2 For any n≥ 1, 1+2+3+···+n=
n(n+1)
2
.
Let S
n
=1+2+3+···+n be the sum of the ﬁrst n natural numbers.
Then S
n
hasa recursive deﬁnition:
B. S
1
=1.
R. S
n
=S
n−1
+n for n>1.
Understanding thisdeﬁnition isthe key to following the inductive argument.
Before digesting the proof, notice how we use the notation of the Principle of
Mathematical Induction.
Statement(n): 1+2+3+···+n=
n(n+1)
2
.
Statement(1): 1 =
1(1+1)
2
.
Statement(k−1): 1+2+3+···+(k−1) =
(k−1)(k−1+1)
2
.
Statement(k): 1+2+3+···+k =
k(k+1)
2
.
Proof (Induction on n.)
Base Case: If n= 1, then the sum of the ﬁrst n natural numbersis1, and
n(n+1)/2=1·2/3 = 1, so Statement(1) is true.
Inductive Hypothesis: Suppose as inductive hypothesis that
1+2+···+(k−1) =
(k−1)(k−1+1)
2
for some k>1.
Inductive Step: Adding k to both sidesof thisequation gives
1+2+···+(k−1) +k =
(k−1)(k−1+1)
2
+k
=
(k−1)(k)+2k
2
=
k
2
+k
2
=
k(k+1)
2
asrequired.
square</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 179 — #39
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 179
The recursive deﬁnition of S
n
guidesthisproof: to move up one level from
S
k−1
to S
k
, the deﬁnition says you just add k. Thisisexactly what we did to
move from Statement(k−1) to Statement(k) in the inductive step of the proof.
Theorem 3.2 is basically the statement that a certain recurrence relation
has a certain closed-form solution, so the proof should remind you of those
in Section 3.2. The next result looksdiﬀerent, but the underlying logic isthe
same, and we follow the same basic template.
Theorem 3.3 Let K(1),K(2),K(3),... be the sequence of shapes whose limit
is the Koch Snowﬂake of Example 3.23. Then K(n), the nth term in this se-
quence, is composed of 4
n−1
·3 line segments.
The recursive deﬁnition of this sequence is important:
B. K(1) isan equilateral triangle.
R. For n>1, K(n) isformed by replacing each line segment
of K(n−1) with the shape
such that the central vertex points outward.
The base case and the inductive steps of the following proof correspond to the
base case and the recursive part of the deﬁnition, respectively.
Proof (Induction on n.)
Base Case: The base case of the deﬁnition states that K(1) consists of
three line segments, and 3 = 4
1−1
·3, so the theorem is true when n=1.
Inductive Hypothesis: Suppose as inductive hypothesis that K(k − 1) is
composed of 4
k−1−1
·3=4
k−2
·3 line segments, for some k>1.
Inductive Step: By the recursive part of the deﬁnition, K(k) isformed
by replacing each line segment with four others, so the number of line
segmentsismultiplied by four. Therefore K(k) iscomposed of 4 ·4
k−2
·3=
4
k−1
·3 line segments, as required.
square
The preceding proof closely resembles the proofs in Section 3.2 because
Statement(n) waswritten in termsof a numerical formula, much like a closed-
form solution. The next example is a little diﬀerent because the claim is stated
completely in the language of strings.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 180 — #40
✐
✐
✐
✐
✐
✐
180 Chapter 3 a73 Recursive Thinking
Theorem 3.4 The string reversal function of Example 3.18 works. In other
words, for any n≥ 1, (a
1
a
2
···a
n−1
a
n
)
R
=a
n
a
n−1
···a
2
a
1
.
Proof (Induction on n.)
Base Case: If n= 1, then a
R
=a by Theorem 3.1, so the reversal function
correctly reverses a one-element string.
Inductive Hypothesis: Suppose as inductive hypothesis that the reversal
function worksfor any string of length k−1, for some k>1.
Inductive Step: Given a string a
1
a
2
a
3
···a
k
of length k,
(a
1
a
2
a
3
···a
k−1
a
k
)
R
= a
k
(a
1
a
2
a
3
···a
k−1
)
R
by deﬁnition of
R
, part R
= a
k
(a
k−1
···a
3
a
2
a
1
) by inductive hypothesis
= a
k
a
k−1
···a
3
a
2
a
1
asrequired.
square
Take another look at thislast proof. It followsthe template of the veri-
ﬁcation of a closed-form solution to a recurrence relation, but the recurrence
relation is replaced by the recursive deﬁnition of the string reversal function.
Otherwise, all the components are the same: check the base case, state the in-
ductive hypothesis, use the recursive deﬁnition, apply the inductive hypothesis,
and simplify to show the desired result.
Proofsinvolving recursive deﬁnitionsoften require induction. The next ex-
ample isquite diﬀerent; it indicatesthe diversity of resultsthat can be proved
using this technique.
Mathematicianssay that a map can be N-colored if there isa way to color
all of the regionsof the map using only N colorsso that no two regionswith a
common border share the same color. Recall the deﬁnition of a line map given
in Example 3.19. Notice that the line map in Figure 3.6 can be two-colored.
Figure 3.16 shows a possible two-coloring. The next theorem says that this was
no accident.
Figure 3.16 A two-coloring of a line map.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 181 — #41
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 181
Theorem 3.5 Any line map can be two-colored.
Proof (Induction on the number of lines.)
Base Case: If a line map contains 0 lines, then it is just a blank rectangle,
so it can be two-colored trivially using a single color.
Inductive Hypothesis: Suppose as inductive hypothesis that any line map
with k−1 linescan be two-colored, for some k>0.
Inductive Step: LetM be a line map withklines. Remove one line fromM,
call it l. By inductive hypothesis, the resulting map can be two-colored,
so two-color it. Now put back l, and reverse the colors of all the regions
on one side of the line l. Each side will still be correctly two-colored, and
any regionshaving l as a border will be opposite colors. Hence the map
M iscorrectly two-colored. square
In this proof, we started our induction at 0 instead of 1. We could have
started at 1, and then the base case would read as follows.
If a line map contains just 1 line, then one side of the line can be colored
white and the other black, so the map can be two-colored.
The rest of the proof would be exactly the same. Sometimes there is a choice
of where to start the base case of an inductive argument.
Figure 3.17 illustrates the reasoning in the inductive step of the proof of
Theorem 3.5. To construct a line map, remove a line l, apply the inductive
hypothesis, put l back, and reverse the colors.
We have been following the same basic template for proofs by induction
since Example 3.10, where we ﬁrst veriﬁed the closed-form solution of a re-
currence relation. Since then we have seen several examples. Although these
examples diﬀer in a variety of ways, they all match a basic pattern, which we
can now state with more generality. In the following template, [object] stands
for some sort of recursively deﬁned object with “levels” for each natural num-
ber, and [property P] stands for the property of the [object] we are trying to
justify.
l
replace l
remove l
apply inductive
hypothesis
reverse top side
Figure 3.17 The reasoning of the inductive step in the proof of Theorem 3.5.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 182 — #42
✐
✐
✐
✐
✐
✐
182 Chapter 3 a73 Recursive Thinking
Template for Inductive Proofs. An inductive proof of the statement “All
[object]shave [property P]” should have the following components.
Base Case: Prove that [property P] holds for the simplest [object].
Inductive Hypothesis: Suppose as inductive hypothesis that
[property P] holdsfor an [object] of level k−1, for some k.
Inductive Step: Suppose as given an [object] of levelk. Use the induc-
tive hypothesis and the recursive deﬁnition of [object] to conclude
that the given level k [object] has[property P].
For example, thisishow the template ﬁtsthe proof of Theorem 3.5.
Base Case: Prove that a line map with 0 linescan be two-colored.
Inductive Hypothesis: Suppose as inductive hypothesis that a line
map with k−1 linescan be two-colored, for some k>0.
Inductive Step: Suppose as given a line map with k lines. Follow the
reasoning in Figure 3.17.
If you are having trouble getting started with an inductive proof, try following
thistemplate.
3.4.3 Strong Induction
So far, in all of the inductive proofs we have considered, the inductive step
involved shows something about a levelkobject using a hypothesis about a level
k−1 object. However, there are times when we will need to use several previous
levels( k−1,k−2,...,etc.) to justify the inductive step. The veriﬁcation of a
closed-form solution for the Fibonacci sequence is a simple example.
Recall that the recurrence relation for these numbers,
F(n)=
braceleftBigg
1ifn=1orn=2
F(n−1) +F(n−2) if n>2,
isa little more complicated than the other recurrence relationswe have studied,
since the recursive part refers to two previousvaluesof F. Observe how the
proof diﬀersaccordingly.
Theorem 3.6 For n≥ 1, the nth Fibonacci number is
F(n)=
α
n
−β
n
α−β
(3.4.1)
where
α=
1+
√
5
2
and β =
1−
√
5
2
.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 183 — #43
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 183
Proof It iseasy to check that α and β are the solutions to the following
equation:
x
2
=x+1. (3.4.2)
Thuswe can use thisequation asan identity for both α and β. We proceed by
induction on n.
Base Case: If n =1orn = 2, the recurrence relation says that F(1) =
1=F(2). Formula 3.4.1 gives
F(1) =
α
1
−β
1
α−β
=
α−β
α−β
=1
and
F(2) =
α
2
−β
2
α−β
=
(α+1)−(β+1)
α−β
, using Equation 3.4.2
=
α−β
α−β
=1,
so the closed-form solution is correct for n= 1 and n=2.
Inductive Hypothesis: Let k>2. Suppose as inductive hypothesis that
F(i)=
α
i
−β
i
α−β
for all i such that 1 ≤i&lt;k.
Inductive Step: Using the recurrence relation,
F(k)=F(k−1) +F(k−2)
=
α
k−1
−β
k−1
α−β
+
α
k−2
−β
k−2
α−β
, by inductive hypothesis
=
α
k−2
(α+1)−β
k−2
(β+1)
α−β
=
α
k−2
(α
2
)−β
k−2
(β
2
)
α−β
, using Equation 3.4.2
=
α
k
−β
k
α−β
asrequired. square</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 184 — #44
✐
✐
✐
✐
✐
✐
184 Chapter 3 a73 Recursive Thinking
Look back at thisproof. The inductive step requiresusto use two previ-
ousvaluesof F(n). That’swhy the inductive hypothesisneedsto be stronger.
Instead of assuming “Statement(k− 1), for some k,” the inductive hypothesis
hasthe form “Statement( i), for all i&lt;k, for some k.” Thisisknown asstrong
induction; we state thisasanother principle.
The Second Principle of Mathematical Induction. To prove the state-
ment
“Statement(n), for all n≥ 1,”
it suﬃces to prove
1. Statement(1), and
2. Statement(1) ∧ Statement(2) ∧···∧Statement(k− 1) ⇒ Statement(k),
for k>1.
In other words, strong induction takes as its inductive hypothesis all pre-
vious cases, not just the immediate predecessor. As with simple induction, we
are establishing a chain of implications that demonstrate Statement(n) for any
value of n.
Statement(1) ⇒ Statement(2)
Statement(1)∧Statement(2) ⇒ Statement(3)
Statement(1)∧Statement(2)∧Statement(3) ⇒ Statement(4)
···⇒···
Asbefore, each implication isof the form P ⇒ Q, but thistime P isthe
conjunction of all previously established cases. In other words, P isa stronger
assumption. This can make proving the inductive step easier, because you have
more to work with.
The form of an inductive proof is the same with strong induction as it
was with simple induction: prove the base case, state the inductive hypothesis,
and use the recursive deﬁnition to prove the next case. Only the inductive
hypothesis is diﬀerent.
Example 3.25 Theorem 2.9 states that a connected graph with no simple
circuits is a tree. We can use strong induction to show that binary trees (as
deﬁned in Example 3.22) are connected and have no simple circuits.
Proof (Strong induction on the height of the tree.)
Base Case: A binary tree of height 0 consists of only a single vertex, so
thisgraph isconnected and hasno simple circuits.
Inductive Hypothesis: Suppose as inductive hypothesis that any binary tree
with height less than k is connected and has no simple circuits, for some
k>1.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 185 — #45
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 185
Inductive Step: Suppose as given a binary tree T with height k. By the
deﬁnition in Example 3.22, T consists of a root node r with edgesgoing
to two subtrees T
1
and T
2
, each having height less than k. By inductive
hypothesis, T
1
and T
2
are each connected and have no simple circuits.
Since T
1
and T
2
are connected, there isa path from r to any vertex in T
1
and T
2
, and therefore there isa path from any vertex in T to any other
vertex. So T isconnected, asrequired. Since T
1
and T
2
have no simple
circuits, any simple circuit in T must pass through r. But in order for a
circuit to begin and end in T
1
(or T
2
), the circuit must pass through r
twice—once to get out of T
1
, and once to get back in. Such a circuit is
not simple. So T has no simple circuits, as required. square
In the following example, notice that we must suppose that all previous
primesare productsof primesin the inductive step. If we made only the weaker
hypothesis that the preceding prime was a product of primes—as with simple
induction—the argument wouldn’t work.
Theorem 3.7 Every integer n≥ 2 is either prime or the product of primes.
Proof (Strong induction on n.)
Base Case: The only factorsof 2 are 1 and 2, so 2 isprime.
Inductive Hypothesis: Let k>2 be given. Suppose as inductive hypothesis
that every i issuch that 2 ≤ i&lt;kiseither prime or the product of
primes.
Inductive Step: If k isprime, we are done. If k isnot prime, then k = pq
for some p ≥ 2 and q ≥ 2. And since k = pq, p and q are both less than
k. By inductive hypothesis, p and q are both either prime or productsof
primes, so k =pq isthe product of primes. square
3.4.4 Structural Induction
In all of the previous examples, induction has been “on” some discrete quantity:
proofsinvolving formulasof ntend to use use induction onn; proofsabout line
maps use induction on the number of lines, etc. In some cases, however, it can
be awkward to specify this quantity.
Example 3.26 Deﬁne a set X ⊆ Z recursively as
B. 4 ∈X.
R
1
. If x∈X then x−12 ∈X.
R
2
. If x∈X then x
2
∈X.
Prove that every element of X isdivisible by 4.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 186 — #46
✐
✐
✐
✐
✐
✐
186 Chapter 3 a73 Recursive Thinking
Before looking at the proof, notice that the two recursive cases move in op-
posite directions: changingxtox−12 returnsa smaller number, while changing
x to x
2
returns a larger number. So it isn’t natural to write the statement we
are trying to prove in termsof n, for n ≥ 1. The point of a structural induc-
tion proof is that the recursive case of the deﬁnition maintains the property of
divisibility by 4.
Proof of Example 3.26 (Induction on the recursive deﬁnition of X.)
Base Case: Since 4 = 1·4, 4 | 4, so the claim holds for the base case of the
deﬁnition.
Inductive Hypothesis: Suppose as inductive hypothesis that some x∈X is
divisible by 4. Then x=4a for some integer a.
Inductive Step: Nowx−12 = 4a−12=4(a−3), andx
2
=(4a)
2
= 4(4a
2
),
so both x− 12 and x
2
are divisible by 4. Therefore cases R
1
and R
2
alwaysproduce integersthat are divisible by 4 (given that 4 |x), and the
base case B givesan integer that isdivisible by 4. So, by induction, all
elementsof X are divisible by 4. square
Pay particular attention to the inductive hypothesisin thisproof: it is
supposing that some element x∈X has the desired property. In earlier proofs,
we thought ofxasan “object of level k−1,” and we proved something about all
“objectsof level k.” Here we avoid the issue of how many levels an object has,
focusing on the base and recursive cases of the deﬁnition. We call this “induction
on the recursive deﬁnition” because we are really doing induction on the number
of times the recursive part of the deﬁnition is used to obtain an element of
X. We show that zero uses of the recursive part of the deﬁnition produces an
element with the desired property, and then we suppose as inductive hypothesis
that k−1 uses of the recursive deﬁnition yields an element x with the desired
property. Finally, we show that one more use of the recursive deﬁnition produces
an element with the desired property. All this while, the variable k operatesin
the background, so it isn’t really necessary to mention it in the proof.
This type of induction is also called “structural induction,” because it uses
the recursive structure of an object to guide the inductive argument.
Example 3.27 Theorem 3.5 states that any line map can be two-colored. Here
is an alternate version of the proof of this theorem using structural induction.
Proof (Induction on the deﬁnition of a line map [Example 3.19].)
Base Case: The base case of a line map is a blank rectangle, which can be
two-colored because it can be one-colored.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 187 — #47
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 187
Inductive Hypothesis: Suppose as inductive hypothesis that some line map
M
prime
can be two-colored. Make a two-coloring of M
prime
.
Inductive Step: The recursive part of the deﬁnition says that a new line
map M can be formed from M
prime
by drawing some line l all the way across
M
prime
. Now reverse the colors of all the regions on one side of the line l.
Each side will still be correctly two-colored, and any regions having l asa
border will be opposite colors. Hence the mapM iscorrectly two-colored.
So by induction, the recursive deﬁnition of a line map always gives a
two-colorable map.
square
Remember that mathematical induction is a recursive technique; self-
reference occursin the inductive step of the proof. Thisiswhy many of the
examples in this section make use of the recursive deﬁnitions from Section 3.3.
Often the presence of a recursive deﬁnition indicates the need for an induc-
tive proof, and the key to constructing an inductive argument lies in thinking
recursively about the problem.
Exercises 3.4
1. Prove that the sum of the ﬁrst n odd natural numbersis n
2
.
2. You may already have a notion of what a convex region is, but here’s a
mathematical deﬁnition.
Deﬁnition 3.2 A region R is convex if the line segment connecting any
two pointsin R liesin R. A polygon isconvex if it and itsinterior form
a convex region.
A consequence of thisdeﬁnition isthat all the diagonalsof a convex
polygon lie inside the polygon. Use induction to prove that a convex n-
gon has n(n− 3)/2 diagonals. (Hint: Think of an n-gon ashaving an
(n−1)-gon inside of it.)
3. Use induction to prove that the sum of the angles of a convex n-gon is
180(n−2) degrees.
4. Prove that any palindrome with an even number of letterscan be con-
structed using the deﬁnition in Example 3.16. Use induction on n, where
2n isthe length of the palindrome. So you need to prove that the string
a
n
a
n−1
···a
2
a
1
a
1
a
2
···a
n−1
a
n
can be constructed, for all n≥ 1.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 188 — #48
✐
✐
✐
✐
✐
✐
188 Chapter 3 a73 Recursive Thinking
5. Prove that any palindrome with an odd number of letterscan be con-
structed using the deﬁnition in Example 3.16.
6. Prove by induction that all of the hexagonal numbersare odd. (See Ex-
ample 3.4.)
7. Recall the deﬁnition of a line map (Example 3.19).
(a) Prove by induction that a line map with n distinct lineshasat least
n+ 1 regions.
(b) Prove by induction that a line map with n distinct lines has at most
2
n
regions.
(c) Part (a) givesa lower bound on the number of regionsin a line map.
For example, a line map with ﬁve lines must have at least six regions.
Give an example of a line map that achievesthislower bound, that
is, draw a line map with ﬁve lines and six regions.
(d) Part (b) saysthat a line map with three linescan have at most eight
regions. Can you draw a line map with three linesthat achievesthis
upper bound? Do so, or explain why you can’t.
8. Let the following deﬁnitionsbe given, where s isa string.
Deﬁnition 1. Deﬁne the number l(s) asfollows.
B
1
. l(s)=0ifs isthe empty string.
B
2
. l(s)=1ifs is a single symbol.
R. l(s)=l(x)+l(y)ifs=xy.
Deﬁnition 2. Letnbe a natural number. Deﬁne the stringnsasfollows:
B. 1s=s.
R. ns=(n−1)s if n>1.
Use these deﬁnitions to prove that l(ns)=nl(s) for all n≥ 1.
9. Use the recursive deﬁnition in Example 3.22 to prove that a binary tree
with height n haslessthan 2
n+1
nodes.
10. Refer to Exercise 15 of Section 3.3 for the deﬁnition of a full binary tree.
(a) Use strong induction to prove that a full binary tree has an odd
number of nodes.
(b) Prove that a full binary tree hasan even number of edges.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 189 — #49
✐
✐
✐
✐
✐
✐
3.4 Proof by Induction 189
11. In Exercise 3 of Section 3.1, we deﬁned the following recurrence relation:
H(n)=





0ifn≤ 0
1in=1orn=2
H(n−1) +H(n−2)−H(n−3) if n>2
.
Prove that H(2n)=H(2n−1) =n for all n≥ 1.
12. The LucasnumbersL(n) are deﬁned in Exercise 4 of Section 3.1, and the
Fibonacci numbers F(n) are given by Deﬁnition 3.1. Prove that L(n)=
F(n−1) +F(n+ 1) for all n≥ 2.
13. Prove that B(n), the nth term in the sequence of shapes whose limit is
the Badda-Bing fractal of Example 1.17, has4 · 3
n−1
free vertices(i.e.,
verticesthat lie on only one square) for all n≥ 1.
14. Prove that B(n), the nth term in the sequence of shapes whose limit is
the Badda-Bing fractal of Example 1.17, consists of 2·3
n−1
−1 squares,
for n≥ 1.
15. Prove that K(n), the nth term in the sequence of shapes whose limit is
the Koch snowﬂake fractal of Example 3.23, has perimeter 3 · (4/3)
n−1
,
where the equilateral triangle in K(1) hasside length of 1 unit.
16. Find a formula for the area of (the black part of) S(n), the nth term
in the sequence of shapes whose limit is the Sierpinski gasket fractal in
Figure 3.11 on page 174. Assume that S(1) isa black equilateral triangle
with area 1. Prove that your formula iscorrect.
17. Let X be the set deﬁned in Example 3.21.
(a) Prove, by induction onn, that 2n+1∈X for alln≥ 0. (Thisshows
that X containsall the odd natural numbers.)
(b) Prove by induction that every element inX isodd. (Thisshowsthat
the set of all odd natural numbers contains X.)
(c) Together, what do (a) and (b) show?
18. Deﬁne a set X recursively as follows.
B. 2 ∈X.
R. If x∈X,soisx+ 10.
Use induction to prove that every element of X iseven.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 190 — #50
✐
✐
✐
✐
✐
✐
190 Chapter 3 a73 Recursive Thinking
19. Deﬁne a set X recursively as follows.
B. 3 and 7 are in X.
R. If x and y are in X,soisx+y. (Here it is possible that x=y.)
Prove that, for every n≥ 12, n∈X. (Hint: For the base case, show that
12, 13, and 14 are in X.)
20. In the game of chess, a knight moves by jumping to a square that is two
unitsaway in one direction and one unit away in another. For example, in
Figure 3.18, the knight at K can move to any of the squares marked with
an asterisk ∗. Prove by induction that a knight can move from any square
to any other square on an n×n chessboard via a sequence of moves, for
all n≥ 4.
K
*
*
*
* *
*
*
*
Figure 3.18 A knight can move to a square with a 2×1 L-shaped jump.
3.5 Recursive Data Structures
In this section we will see how thinking recursively about how to organize data
can lead to elegant solutions. We will give recursive deﬁnitions for lists and trees,
and we will use these deﬁnitions to deﬁne useful functions on these structures.
Moreover, we will prove that these functions do what they are supposed to do.
Since the deﬁnitions and functions are recursive, most of these proofs will use
induction.
3.5.1 Lists
Almost every computer application uses some kind of list object. A list isa set
of data elements in some sequential order
x
1
,x
2
,x
3
,...,x
n</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 191 — #51
✐
✐
✐
✐
✐
✐
3.5 Recursive Data Structures 191
where all of the x
i
’s are of the same type (e.g., integers, strings, etc.). You can
make a list of n elementsby adding an element to the end of a list of n− 1
elements; this observation inspires the following recursive deﬁnition.
Deﬁnition 3.3 Let X be a set. A list of elementsof X is:
B. x where x∈X.
R. L,x where x∈X and L isa list of elementsof X.
Notice that, unlike a set, a list may repeat the same element several times,
and the order of the elements matters. Every symbol in this deﬁnition is im-
portant; the commasbetween the list elementsare part of the structure of a
list. For example, we can build up the list of strings
cubs,bears,bulls,cubs
in a bottom-up fashion using this deﬁnition.
L
1
= cubs by part B
L
2
= L
1
,bears = cubs,bears by part R
L
3
= L
2
,bulls = cubs,bears,bulls by part R
L
4
= L
3
,cubs = cubs,bears,bulls,cubs by part R
One advantage to deﬁning lists recursively is that it makes it possible to
deﬁne recursive functions that tell us something about the data in the list. For
example, we can use recursion to add up all the elements in a list of integers.
Deﬁnition 3.4 Let L be a list as deﬁned by Deﬁnition 3.3, where X = R, the
real numbers. Deﬁne a function Sum(L) recursively as follows.
B. If L=x, a single number, then Sum(L)=x.
R. If L=L
prime
,xfor some list L
prime
, then Sum(L) = Sum(L
prime
)+x.
Notice how the base and recursive cases of this deﬁnition match the base
and recursive cases of Deﬁnition 3.3. The recursive structure of a list determines
the way we write recursive functions.
Example 3.28 To evaluate the Sum function on the list 3,1,4,2, it isnatural
to take a top-down approach.
Sum(3,1,4,2) = Sum(3,1,4) + 2 by part R
= Sum(3,1)+4+2 bypart R
= Sum(3)+1+4+2 bypart R
= 3+1+4+2 bypart B
=10.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 192 — #52
✐
✐
✐
✐
✐
✐
192 Chapter 3 a73 Recursive Thinking
The Sum function returns the correct answer for the list 3,1,4,2, but will
it always work? We can prove that it does, using induction.
Theorem 3.8 Let L be the list x
1
,x
2
,x
3
,...,x
n
, where the x
i
’s are numbers.
Then
Sum(L)=x
1
+x
2
+x
3
+···+x
n
for all n≥ 1.
Proof (Induction on the size of the list.)
Base Case: If L containsonly a single number x, then the base case of the
deﬁnition stipulates that Sum(L)=x, asrequired.
Inductive Hypothesis: Let k>1. Suppose as inductive hypothesis that
Sum(L
prime
)=x
1
+x
2
+x
3
+···+x
k−1
for any list L
prime
containing k−1 elements.
Inductive Step: Suppose as given a list
L=x
1
,x
2
,x
3
,...,x
k
with k elements. Then, by Deﬁnition 3.3, L=L
prime
,x
k
, where L
prime
isa list of
k−1 elements. Therefore,
Sum(L) = Sum(L
prime
)+x
k
by part R
=(x
1
+x
2
+x
3
+···+x
k−1
)+x
k
by inductive hypothesis
= x
1
+x
2
+x
3
+···+x
k
asrequired.
square
The next recursive deﬁnition is for educational purposes only; the object
it deﬁnes is simple and somewhat limited. The point is to help us study ways
to search for an element in a list.
Deﬁnition 3.5 An SList is
B. x where x∈ R, the real numbers.
R. (X,Y) whereX andY are SLists having the same number of elements,
and the last number in X is less than the ﬁrst number in Y.
For example, (((1,3),(8,9)),((12,16),(25,30))) isan SList. Notice that
SListsalwayshave 2
p
elements, for some p ≥ 0. (The proof of thisfact is
left asan exercise.) The number p countsthe depth of parentheses of the SList,</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 193 — #53
✐
✐
✐
✐
✐
✐
3.5 Recursive Data Structures 193
or more simply, the depth of the SList; every number in the list will be inside
p pairs of parentheses. So the example SList above has depth 3 and contains
2
3
elements. Also notice that if L=(X,Y) isan SList of depth p, then X and
Y must have depth p−1.
What’sthe “S” for? The elementsof an SList must be sorted in order from
left to right. That’sanother exercise.
Suppose we want to deﬁne a function that will tell us whether or not a given
number is in the list. Since the list is deﬁned recursively, it is natural to deﬁne
the function recursively as well. Note that the base and recursive cases of the
following function correspond to the base and recursive cases of Deﬁnition 3.5.
Deﬁnition 3.6 Deﬁne a true or false function Search(t,L), wheretisa number
(the “target”) and L is an SList, as follows.
B. Suppose L=x, a list of depth 0. Then
Search(t,L)=
braceleftBigg
true if t=x
false if tnegationslash=x.
R. Suppose the depth of L isgreater than 0, so L=(X,Y). Then
Search(t,L) = Search(t,X)∨Search(t,Y).
.
The Search function is supposed to tell if a given element is in the list. For
example, let L = (((1,3),(8,9)),((12,16),(25,30))). The following calculation
showshow to calculate the Search function on thislist, with a target value of 8:
Search[8,L] = Search[8,((1,3),(8,9))]∨Search[8,((12,16),(25,30))]
= Search[8,(1,3)]∨Search[8,(8,9)]∨Search[8,(12,16)]
∨ Search[8,(25,30)]
= Search[8,1]∨Search[8,3]∨Search[8,8]∨Search[8,9]
∨ Search[8,12]∨Search[8,16]∨Search[8,25]∨Search[8,30]
= false∨false∨true∨false∨false∨false∨false∨false
= true.
Notice how to evaluate a recursive function: rewrite the function in terms of
itself using the recursive step, until (hopefully) you are able to evaluate the
function using the base case. Once the recursion “bottoms out,” you can evalu-
ate the function because there are no more recursive references to the function.
Search[8,L] worked, because it returned “true” and 8 was indeed in the
list. Here is a proof that the Search function works in general.
Theorem 3.9 Search(t,L) ⇐⇒ t is in L.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 194 — #54
✐
✐
✐
✐
✐
✐
194 Chapter 3 a73 Recursive Thinking
Proof (Induction on p, the depth of the SList L.)
Base Case: If p = 0, the list L contains only a single number, say L = x.
The base case of the Search function will set Search(t,L) = true if and
only if t=x. Therefore
Search(t,L) ⇐⇒ t=x ⇐⇒ t isin L
when the depth of the list is 0.
Inductive Hypothesis: Suppose as inductive hypothesis that the Search
function worksfor any list L
prime
of depth k − 1, for some k>0. That
is, if L
prime
hasdepth k−1, then we suppose that
Search(t,L
prime
) ⇐⇒ t isin L
prime
.
Inductive Step: Given a list L of depth k, we know that L =(X,Y) for
some X and Y of depth k−1. So
Search(t,L) = Search(t,X)∨Search(t,Y)
by the recursive part of the function deﬁnition. Now
t isin L ⇐⇒ (t isin X)∨(t isin Y) by the deﬁnition of SList
⇐⇒ Search(t,X)∨Search(t,Y) by inductive hypothesis
⇐⇒ Search(t,L) by the deﬁnition of Search.
So for any SList of any depth, the Search function will be true if and only
if the target isin the list. square
This Search function isn’t very clever: it does not use the fact that an SList
hasto be in order. Let’slook at another function designed to test whether a
given number isin an SList.
Deﬁnition 3.7 Deﬁne a true or false function BSearch(t,L), wheretisa num-
ber and L isan SList, asfollows.
B. Suppose L=x, a list of depth 0. Then
BSearch(t,L)=
braceleftBigg
true if t=x
false if tnegationslash=x.
R. Suppose L hasdepth p>0, so L =(X,Y). Let r be the last element of
X. Then
BSearch(t,L)=
braceleftBigg
BSearch(t,Y)ift>r
BSearch(t,X)iftnegationslash>r.</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 195 — #55
✐
✐
✐
✐
✐
✐
3.5 Recursive Data Structures 195
For example, letL= (((1,3),(8,9)),((12,16),(25,30))), and try ﬁnding the
number 8 using BSearch. Compare this calculation to the same search using
the old (not smart) Search function:
BSearch[8,L] = BSearch[8,((1,3),(8,9))] since 8 negationslash>9
= BSearch[8,(8,9)] since 8>3
= BSearch[8,8] since 8 negationslash>8
= true since 8 = 8.
BSearch appearsto be a more clever function. It lookslike the BSearch function
takeslesswork (and time) to evaluate than the Search function.
3.5.2 Eﬃciency
If these two search functions were implemented on a computer, we would prob-
ably expect BSearch to run more eﬃciently. How much better isit? To answer
this question, we can try to count the number of operations each function does.
In practice, instead of counting every single operation, computer scientists try
to count the number of occurrences of the most time-consuming operation. For
our functions, assume that these are the comparisons t
?
=x and t
?
>r.
First consider the Search function. Let C(p) be the number of timesthe
comparison t
?
= x is done when searching a list of depth p.Ifp = 0, then the
list contains only a single item, so the base case B of the deﬁnition getsused
and one comparison is made. Therefore C(0) = 1.
Now suppose the Search function is evaluated on a list of depthp, for some
p>0. Then the recursive case R of the deﬁnition getsused, and the Search
function isexecuted twice on listsof depth p− 1. Each of these two recursive
callsuses C(p − 1) comparisons. Therefore C(p) must satisfy the following
recurrence relation:
C(p)=
braceleftBigg
1ifp=0
2C(p−1) if p>0.
(3.5.1)
This recurrence relation is easy to solve: C(p)=2
p
. Since an SList of depth p
contains2
p
elements, the number of comparisons made by the Search function
equalsthe number of elementsin the list.
Similarly, we can derive a recurrence relation for the BSearch function.
For a list containing a single item, the base case of the function requires one
comparison. On a list of depthp,p>0, the recursive part of the deﬁnition ﬁrst
makesone comparison, and then callsthe BSearch function on a list of depth</p>
      <p>✐
✐
“48927˙CH03˙Hunter” — 2008/10/20 — 15:18 — page 196 — #56
✐
✐
✐
✐
✐
✐
196 Chapter 3 a73 Recursive Thinking
p− 1. If we use D(p) to represent the number of comparisons needed, we get
the following recurrence relation:
D(p)=
braceleftBigg
1ifp=0
1+D(p−1) if p>0.
(3.5.2)
Thisrecurrence relation iseven easier to solve: D(p)=p+1. So you only need
p+1 comparisons to ﬁnd an element in a list of size 2
p
. In other words, to ﬁnd
anumberinalistofN elementsusing BSearch, you need to make log
2
N +1
comparisons.
Asthe size of the list getslarge, BSearch becomesa much better alter-
native to Search. For example, a list containing 1,048,576 elements requires
1,048,576 comparisons using Search, but only 21 comparisons using BSearch.
Such considerations are important when writing computer programs that use
these functions. We will study these issues in more depth in Chapter 5.
Here’s one more recursive function that will be used in the exercises.
Example 3.29 Deﬁne a numerical function Sum(L), where L isan SList, as
follows.
B. If L=n, then Sum(L)=n.
R. If L=(X,Y), then Sum(L) = Sum(X) + Sum(Y).
Thisversion of the Sum function diﬀersfrom Deﬁnition 3.4 in exactly the
ways that SLists diﬀer from lists; the recursive deﬁnition of the object guides
the recursive deﬁnition of the function.
3.5.3 Binary Search Trees Revisited
We have already considered recursive deﬁnitions for binary trees in general (Ex-
ample 3.22). Now that we are used to thinking recursively about data struc-
tures, it is natural to write down the following recursive deﬁnition for a binary
search tree. (Compare this deﬁnition with the discussion in Example 2.5 on
page 68.)
Deﬁnition 3.8 Let S be a set that is totally ordered by ≤.Abinary search
tree on S is
B
1
. The empty tree, or
B
2
. a single vertex r∈S. In thiscase, r isthe root of the tree.
R. IfT
1
andT
2
are binary search trees with rootsr
1
andr
2
respectively, and
if a≤r for all nodes a∈T
1
and r≤b for all nodes b∈T
2
, then the tree</p>
    </div>
  </body>
</html>